import os
from datetime import datetime, timezone
from typing import List, Dict, Any

from pymongo import ASCENDING, MongoClient


class FootyMongoStore:
    """
    MongoDB storage with 3 collections - In-place event enhancement!
    
    Collections:
    - fixtures_staging: Fixtures waiting to start (TBD, NS)
    - fixtures_active: Enhanced with debounce data IN events array
    - fixtures_completed: Archive
    
    Event Enhancement (in fixtures_active.events array):
    Each event gets additional fields prefixed with _ to avoid API conflicts:
    - _event_id: Unique ID like "5000_234_Goal_1"
    - _stable_count: Debounce counter (1, 2, 3)
    - _debounce_complete: Boolean flag
    - _twitter_complete: Boolean flag
    - _first_seen: Timestamp when first detected
    - _snapshots: Array of {timestamp, hash} for debounce tracking
    - _score_before: {"home": 0, "away": 0}
    - _score_after: {"home": 1, "away": 0}
    - _twitter_search: "Player Team"
    """
    
    def __init__(self, connection_url=None):
        if connection_url is None:
            connection_url = os.getenv('MONGODB_URL', 'mongodb://localhost:27017/')
        
        self.client = MongoClient(connection_url)
        self.db = self.client.found_footy
        
        # 3 Collections - Simple!
        self.fixtures_staging = self.db.fixtures_staging
        self.fixtures_active = self.db.fixtures_active
        self.fixtures_completed = self.db.fixtures_completed
        
        self._create_indexes()

    def _create_indexes(self):
        """Create indexes"""
        try:
            # Status indexes
            self.fixtures_staging.create_index([("fixture.status.short", ASCENDING)])
            self.fixtures_active.create_index([("fixture.status.short", ASCENDING)])
            self.fixtures_completed.create_index([("fixture.status.short", ASCENDING)])
            
            # Date indexes
            self.fixtures_staging.create_index([("fixture.date", ASCENDING)])
            self.fixtures_active.create_index([("fixture.date", ASCENDING)])
            self.fixtures_completed.create_index([("fixture.date", ASCENDING)])

            # Team indexes
            self.fixtures_staging.create_index([("teams.home.id", ASCENDING)])
            self.fixtures_staging.create_index([("teams.away.id", ASCENDING)])
            self.fixtures_active.create_index([("teams.home.id", ASCENDING)])
            self.fixtures_active.create_index([("teams.away.id", ASCENDING)])
            
            # Enhanced event fields (in events array)
            self.fixtures_active.create_index([("events._event_id", ASCENDING)])
            self.fixtures_active.create_index([("events._debounce_complete", ASCENDING)])
            
            print("✅ MongoDB indexes created successfully")
        except Exception as e:
            print(f"⚠️ Error creating indexes: {e}")

    # ===== STAGING METHODS =====
    
    def save_fixtures_to_staging(self, fixtures: List[dict]) -> int:
        """Bulk insert fixtures to staging"""
        try:
            if not fixtures:
                return 0
            result = self.fixtures_staging.insert_many(fixtures, ordered=False)
            return len(result.inserted_ids)
        except Exception as e:
            print(f"⚠️ Error saving to staging: {e}")
            return 0

    def get_staging_fixtures(self) -> List[dict]:
        """Get all fixtures from staging"""
        try:
            return list(self.fixtures_staging.find({}))
        except Exception as e:
            print(f"❌ Error getting staging fixtures: {e}")
            return []

    # ===== ACTIVE METHODS =====
    
    def activate_fixture(self, fixture_id: int, fixture_doc: dict) -> bool:
        """Move fixture from staging to active"""
        try:
            doc = dict(fixture_doc)
            doc["_id"] = fixture_id
            self.fixtures_active.insert_one(doc)
            self.fixtures_staging.delete_one({"_id": fixture_id})
            return True
        except Exception as e:
            print(f"❌ Error activating fixture {fixture_id}: {e}")
            return False

    def get_active_fixture_ids(self) -> List[int]:
        """Get list of active fixture IDs"""
        try:
            return [doc["_id"] for doc in self.fixtures_active.find({}, {"_id": 1})]
        except Exception as e:
            print(f"❌ Error getting active fixture IDs: {e}")
            return []

    def get_fixture_from_active(self, fixture_id: int) -> dict | None:
        """Get fixture from active collection"""
        try:
            return self.fixtures_active.find_one({"_id": fixture_id})
        except Exception as e:
            print(f"❌ Error getting fixture {fixture_id}: {e}")
            return None

    def update_fixture_with_fresh_data(self, fixture_id: int, api_data: dict) -> bool:
        """
        Update ENTIRE fixture document with fresh API data.
        This replaces everything including events array with latest from API.
        Enhanced fields in events (_event_id, _stable_count, etc.) will be re-added by debounce job.
        """
        try:
            doc = dict(api_data)
            doc["_id"] = fixture_id
            result = self.fixtures_active.replace_one({"_id": fixture_id}, doc)
            return result.modified_count > 0
        except Exception as e:
            print(f"❌ Error updating fixture {fixture_id}: {e}")
            return False

    # ===== EVENT ENHANCEMENT METHODS (In-Place Updates) =====
    
    def add_event_enhancement(self, fixture_id: int, event_index: int, enhancement: Dict[str, Any]) -> bool:
        """
        Add enhancement fields to a specific event in the events array.
        
        Args:
            fixture_id: Fixture ID
            event_index: Index of event in events array
            enhancement: Dict with _event_id, _stable_count, _first_seen, etc.
        """
        try:
            # Build update document with dotted notation
            update_doc = {f"events.{event_index}.{key}": value for key, value in enhancement.items()}
            
            result = self.fixtures_active.update_one(
                {"_id": fixture_id},
                {"$set": update_doc}
            )
            return result.modified_count > 0
        except Exception as e:
            print(f"❌ Error adding event enhancement: {e}")
            return False

    def update_event_stable_count(self, fixture_id: int, event_id: str, stable_count: int, snapshot: Dict[str, Any]) -> bool:
        """
        Update stable_count and add snapshot for an event.
        
        Args:
            fixture_id: Fixture ID
            event_id: Event ID like "5000_234_Goal_1"
            stable_count: New stable count
            snapshot: {timestamp, hash} to append to snapshots
        """
        try:
            result = self.fixtures_active.update_one(
                {"_id": fixture_id, "events._event_id": event_id},
                {
                    "$set": {"events.$._stable_count": stable_count},
                    "$push": {"events.$._snapshots": snapshot}
                }
            )
            return result.modified_count > 0
        except Exception as e:
            print(f"❌ Error updating stable count: {e}")
            return False

    def mark_event_debounce_complete(self, fixture_id: int, event_id: str) -> bool:
        """Mark event as debounce complete (stable_count >= 3)"""
        try:
            result = self.fixtures_active.update_one(
                {"_id": fixture_id, "events._event_id": event_id},
                {
                    "$set": {
                        "events.$._debounce_complete": True,
                        "events.$._debounce_completed_at": datetime.now(timezone.utc)
                    }
                }
            )
            return result.modified_count > 0
        except Exception as e:
            print(f"❌ Error marking debounce complete: {e}")
            return False

    def mark_event_twitter_started(self, fixture_id: int, event_id: str) -> bool:
        """Mark that Twitter search has started"""
        try:
            result = self.fixtures_active.update_one(
                {"_id": fixture_id, "events._event_id": event_id},
                {"$set": {"events.$._twitter_started_at": datetime.now(timezone.utc)}}
            )
            return result.modified_count > 0
        except Exception as e:
            print(f"❌ Error marking twitter started: {e}")
            return False

    def mark_event_twitter_complete(self, fixture_id: int, event_id: str, video_urls: List[str]) -> bool:
        """Mark event as twitter complete with discovered videos"""
        try:
            result = self.fixtures_active.update_one(
                {"_id": fixture_id, "events._event_id": event_id},
                {
                    "$set": {
                        "events.$._twitter_complete": True,
                        "events.$._twitter_completed_at": datetime.now(timezone.utc),
                        "events.$._discovered_videos": video_urls
                    }
                }
            )
            return result.modified_count > 0
        except Exception as e:
            print(f"❌ Error marking twitter complete: {e}")
            return False

    def get_events_needing_debounce(self, fixture_id: int) -> List[Dict[str, Any]]:
        """
        Get events that need debounce processing:
        - NEW: Don't have _event_id yet
        - INCOMPLETE: Have _event_id but _debounce_complete is false
        """
        try:
            fixture = self.fixtures_active.find_one({"_id": fixture_id})
            if not fixture or "events" not in fixture:
                return []
            
            needs_debounce = []
            for idx, event in enumerate(fixture["events"]):
                # NEW event (no _event_id)
                if "_event_id" not in event:
                    needs_debounce.append({"event": event, "index": idx, "status": "new"})
                # INCOMPLETE event
                elif not event.get("_debounce_complete", False):
                    needs_debounce.append({"event": event, "index": idx, "status": "incomplete"})
            
            return needs_debounce
        except Exception as e:
            print(f"❌ Error getting events needing debounce: {e}")
            return []

    def get_events_ready_for_twitter(self, fixture_id: int) -> List[Dict[str, Any]]:
        """Get events where debounce_complete=true but twitter_complete=false"""
        try:
            fixture = self.fixtures_active.find_one({"_id": fixture_id})
            if not fixture or "events" not in fixture:
                return []
            
            ready = []
            for event in fixture["events"]:
                if (event.get("_debounce_complete", False) and 
                    not event.get("_twitter_complete", False)):
                    ready.append(event)
            
            return ready
        except Exception as e:
            print(f"❌ Error getting events ready for twitter: {e}")
            return []

    # ===== COMPLETION METHODS =====
    
    def move_fixture_to_completed(self, fixture_id: int) -> bool:
        """Move fixture from active to completed"""
        try:
            fixture = self.fixtures_active.find_one({"_id": fixture_id})
            if not fixture:
                return False
            
            fixture["completed_at"] = datetime.now(timezone.utc)
            self.fixtures_completed.insert_one(fixture)
            self.fixtures_active.delete_one({"_id": fixture_id})
            return True
        except Exception as e:
            print(f"❌ Error moving fixture to completed: {e}")
            return False

    # ===== UTILITY METHODS =====
    
    def count_fixtures(self, collection_name: str) -> int:
        """Count fixtures in a collection"""
        try:
            collection = getattr(self, collection_name)
            return collection.count_documents({})
        except Exception as e:
            print(f"❌ Error counting {collection_name}: {e}")
            return 0
