# Found Footy - In-Place Event Enhancement Architecture

## üéØ Core Concept

**In-Place Enhancement**: We fetch API data ONCE per fixture and enhance events directly in the events array - no separate tracking collections!

**3 Collections Total**: 
- `fixtures_staging` - Waiting to start
- `fixtures_active` - Raw API + enhanced fields IN events array  
- `fixtures_completed` - Archive

---

## üìä Data Flow

### High-Level Overview

```
1. Ingest Job (Daily 00:05 UTC)
   ‚Üì
   fixtures_staging (TBD, NS fixtures)
   
2. Monitor Job (Every Minute)
   ‚Üì
   - Activate: staging ‚Üí active
   - Fetch fresh API data
   - Replace ENTIRE fixture doc in fixtures_active
   - Return list of fixture_ids needing debounce
   
3. Debounce Job (Per Fixture)
   ‚Üì
   - Read fixtures_active (has fresh API data)
   - Enhance events IN-PLACE with _event_id, _stable_count, etc.
   - Mark _debounce_complete when stable_count >= 3
   
4. Twitter Job (Per Event)
   ‚Üì
   - Read event from fixtures_active
   - Search Twitter using _twitter_search
   - Mark _twitter_complete with _discovered_videos
   
5. Monitor Job (Completion Check)
   ‚Üì
   fixtures_completed (FT, AET, PEN fixtures)
```

---

## üóÑÔ∏è Collection Schemas

### fixtures_staging

Fixtures waiting to start (status TBD, NS).

```json
{
  "_id": 5000,
  "fixture": {
    "id": 5000,
    "date": "2025-11-24T15:00:00Z",
    "status": {"short": "TBD", "long": "Time To Be Defined"}
  },
  "teams": {
    "home": {"id": 40, "name": "Liverpool", "logo": "..."},
    "away": {"id": 50, "name": "Man City", "logo": "..."}
  },
  "league": {"id": 39, "name": "Premier League"},
  "events": []
}
```

### fixtures_active

Active fixtures with enhanced events (IN-PLACE).

**Key Point**: Events array contains RAW API fields PLUS underscore-prefixed enhanced fields.

```json
{
  "_id": 5000,
  "fixture": {
    "id": 5000,
    "date": "2025-11-24T15:00:00Z",
    "status": {"short": "2H", "elapsed": 67}
  },
  "teams": {
    "home": {"id": 40, "name": "Liverpool"},
    "away": {"id": 50, "name": "Man City"}
  },
  "events": [
    {
      // ========== RAW API FIELDS ==========
      "time": {"elapsed": 23, "extra": null},
      "team": {"id": 40, "name": "Liverpool"},
      "player": {"id": 234, "name": "D. Szoboszlai"},
      "assist": {"id": 456, "name": "M. Salah"},
      "type": "Goal",
      "detail": "Normal Goal",
      "comments": null,
      
      // ========== ENHANCED FIELDS (added by debounce_job) ==========
      "_event_id": "5000_234_Goal_1",
      "_stable_count": 3,
      "_debounce_complete": true,
      "_debounce_completed_at": "2025-11-24T15:25:45Z",
      "_twitter_complete": false,
      "_first_seen": "2025-11-24T15:23:45Z",
      "_snapshots": [
        {"timestamp": "2025-11-24T15:23:45Z", "hash": "abc123"},
        {"timestamp": "2025-11-24T15:24:45Z", "hash": "abc123"},
        {"timestamp": "2025-11-24T15:25:45Z", "hash": "abc123"}
      ],
      "_score_before": {"home": 0, "away": 0},
      "_score_after": {"home": 1, "away": 0},
      "_scoring_team": "home",
      "_twitter_search": "Szoboszlai Liverpool",
      "_discovered_videos": []
    }
  ]
}
```

### fixtures_completed

Archive of finished fixtures (moved from fixtures_active).

Same schema as fixtures_active with added field:

```json
{
  "_id": 5000,
  "completed_at": "2025-11-24T16:50:00Z",
  "fixture": {...},
  "teams": {...},
  "events": [...]  // With all enhanced fields preserved
}
```

---

## üîÑ Job Details

### 1. Ingest Job (Daily 00:05 UTC)

**Purpose**: Fetch today's fixtures and route by status

**Process**:
```python
1. Fetch fixtures from API-Football for today
2. Filter to 50 tracked teams
3. Route by status:
   - TBD/NS/LIVE ‚Üí fixtures_staging
   - FT/AET/PEN ‚Üí fixtures_completed
```

**Collections Modified**:
- `fixtures_staging` - Receives fixtures
- `fixtures_completed` - Receives already-finished fixtures

---

### 2. Monitor Job (Every Minute)

**Purpose**: Activate fixtures, fetch fresh data, identify debounce needs

**Process**:
```python
1. ACTIVATE FIXTURES:
   For each fixture in staging where start_time <= now:
     - Move to fixtures_active
     - No enhancement yet (raw API data only)

2. BATCH FETCH:
   - Get all active fixture IDs
   - Single API call: GET /fixtures?ids=5000,5001,5002...
   - Returns: fixtures + events + lineups + statistics

3. UPDATE FIXTURES:
   For each fetched fixture:
     - Replace ENTIRE document in fixtures_active
     - This includes fresh events array (raw API data)
     - Any existing enhancement fields are LOST (will be re-added by debounce)

4. IDENTIFY DEBOUNCE NEEDS:
   For each active fixture:
     - Call: store.get_events_needing_debounce(fixture_id)
     - Returns events that are:
       * NEW: No _event_id field
       * INCOMPLETE: _debounce_complete=false
     - If any events need debounce: Add fixture_id to list

5. MOVE COMPLETED:
   For fixtures with status FT/AET/PEN:
     - Move to fixtures_completed
     - Preserve all enhanced fields

6. RETURN:
   - List of fixture_ids needing debounce
```

**Key Insight**: Monitor does NOT enhance events - it just replaces with fresh API data!

**Collections Modified**:
- `fixtures_active` - ALL documents updated with fresh API data
- `fixtures_completed` - Receives finished fixtures

**Triggers**: Returns list to trigger debounce_job per fixture_id

---

### 3. Debounce Job (Per Fixture)

**Purpose**: Validate event stability and enhance events in-place

**Called With**: `fixture_id` from monitor job

**Process**:
```python
1. GET FIXTURE:
   - Read fixtures_active[fixture_id]
   - Has fresh API data (from monitor job)

2. GET EVENTS NEEDING DEBOUNCE:
   - Call: store.get_events_needing_debounce(fixture_id)
   - Returns list of {event, index, status}
   - Status is either "new" or "incomplete"

3. PROCESS EACH EVENT:
   
   IF event is NEW (no _event_id):
     a. Generate event_id: {fixture}_{player}_{type}_{sequence}
     b. Calculate score context:
        - _score_before: Count goals up to this event
        - _score_after: Add this goal
        - _scoring_team: "home" or "away"
     c. Build twitter search: "{player_last_name} {team_name}"
     d. Generate hash from event data
     e. Add enhancement:
        - _event_id
        - _stable_count = 1
        - _debounce_complete = false
        - _twitter_complete = false
        - _first_seen = now
        - _snapshots = [{"timestamp": now, "hash": hash}]
        - _score_before, _score_after, _scoring_team
        - _twitter_search
     f. Update event in-place: store.add_event_enhancement(fixture_id, index, enhancement)
   
   ELSE event is INCOMPLETE (_debounce_complete=false):
     a. Generate hash from current event data
     b. Get last snapshot hash
     c. IF hash == last_hash:
        - Event is STABLE
        - Increment stable_count
        - Add new snapshot
        - IF stable_count >= 3:
          - Mark _debounce_complete=true
          - Add _debounce_completed_at timestamp
        - Update: store.update_event_stable_count(fixture_id, event_id, count, snapshot)
        - IF complete: store.mark_event_debounce_complete(fixture_id, event_id)
     d. ELSE hash != last_hash:
        - Event is UNSTABLE (API changed the data)
        - Reset stable_count to 1
        - Add new snapshot with new hash
        - Update: store.update_event_stable_count(fixture_id, event_id, 1, snapshot)

4. LOG RESULTS:
   - {new_count} new events
   - {updated_count} events checked
   - {completed_count} events completed debounce
```

**Hash Generation**:
```python
key_fields = {
    "player_id": event["player"]["id"],
    "team_id": event["team"]["id"],
    "type": event["type"],
    "detail": event["detail"],
    "time_elapsed": event["time"]["elapsed"],
    "assist_id": event["assist"]["id"] if assist else None
}
hash = md5(json.dumps(key_fields, sort_keys=True))
```

**Collections Modified**:
- `fixtures_active` - Events array updated in-place with enhanced fields

**Triggers**: Twitter job for events where _debounce_complete=true

---

### 4. Twitter Job (Per Event)

**Purpose**: Search Twitter and save discovered video URLs

**Called With**: `fixture_id`, `event_id` 

**Process**:
```python
1. GET EVENT:
   - Read fixtures_active[fixture_id]
   - Find event where _event_id == event_id

2. GET SEARCH STRING:
   - Use event._twitter_search (prebuilt by debounce job)
   - Example: "Szoboszlai Liverpool"

3. MARK STARTED:
   - store.mark_event_twitter_started(fixture_id, event_id)
   - Adds _twitter_started_at timestamp

4. SEARCH TWITTER:
   - Use _twitter_search with filter:videos
   - TODO: Implement actual Twitter search
   - Currently returns [] (placeholder)

5. MARK COMPLETE:
   - store.mark_event_twitter_complete(fixture_id, event_id, video_urls)
   - Sets _twitter_complete=true
   - Adds _twitter_completed_at timestamp
   - Stores video_urls in _discovered_videos array
```

**Collections Modified**:
- `fixtures_active` - Event updated with _twitter_complete and _discovered_videos

---

## üé® Enhanced Fields Reference

### Event Enhancement Fields

All fields prefixed with `_` to avoid API conflicts:

| Field | Type | Description | Added By | When |
|-------|------|-------------|----------|------|
| `_event_id` | string | Unique ID: {fixture}_{player}_{type}_{seq} | debounce_job | First poll |
| `_stable_count` | int | Debounce counter (1, 2, 3) | debounce_job | Each poll |
| `_debounce_complete` | bool | Stability validated (count >= 3) | debounce_job | 3rd poll |
| `_debounce_completed_at` | ISO8601 | When debounce completed | debounce_job | 3rd poll |
| `_twitter_complete` | bool | Video search completed | twitter_job | After search |
| `_twitter_started_at` | ISO8601 | When search started | twitter_job | Start |
| `_twitter_completed_at` | ISO8601 | When search finished | twitter_job | End |
| `_first_seen` | ISO8601 | When event first detected | debounce_job | First poll |
| `_snapshots` | array | [{timestamp, hash}] history | debounce_job | Each poll |
| `_score_before` | object | {home: 0, away: 0} | debounce_job | First poll |
| `_score_after` | object | {home: 1, away: 0} | debounce_job | First poll |
| `_scoring_team` | string | "home" or "away" | debounce_job | First poll |
| `_twitter_search` | string | "Player Team" | debounce_job | First poll |
| `_discovered_videos` | array | [url1, url2, ...] | twitter_job | After search |

---

## üîç Query Patterns

### Get Active Fixtures with Enhanced Events

```javascript
// Get single fixture with all enhanced events
db.fixtures_active.findOne({_id: 5000})

// Get events needing Twitter search
db.fixtures_active.aggregate([
  {$match: {_id: 5000}},
  {$unwind: "$events"},
  {$match: {
    "events._debounce_complete": true,
    "events._twitter_complete": false
  }},
  {$project: {
    event_id: "$events._event_id",
    search: "$events._twitter_search"
  }}
])

// Count events by status per fixture
db.fixtures_active.aggregate([
  {$unwind: "$events"},
  {$group: {
    _id: "$_id",
    total_events: {$sum: 1},
    new_events: {$sum: {$cond: [{$exists: "$events._event_id"}, 0, 1]}},
    incomplete: {$sum: {$cond: ["$events._debounce_complete", 0, 1]}},
    complete: {$sum: {$cond: ["$events._debounce_complete", 1, 0]}}
  }}
])
```

### UI Data Fetch

For frontend display, single query gets everything:

```javascript
// Get fixture with enhanced events
const fixture = await db.fixtures_active.findOne({_id: fixtureId})

// Display fixture info
console.log(`${fixture.teams.home.name} ${fixture.goals.home} - ${fixture.goals.away} ${fixture.teams.away.name}`)

// Display events with live status
fixture.events
  .filter(e => e._event_id)  // Only enhanced events
  .forEach(event => {
    if (!event._debounce_complete) {
      show(`‚è≥ Validating: ${event._twitter_search}`)
    } else if (!event._twitter_complete) {
      show(`üîç Searching: ${event._twitter_search}`)
    } else {
      show(`‚úÖ ${event.player.name} ${event.time.elapsed}' (${event._discovered_videos.length} videos)`)
    }
  })
```

---

## üöÄ Benefits of In-Place Enhancement

1. **Simplicity**: 3 collections instead of 6
2. **Single Source**: fixtures_active has everything
3. **No Joins**: All data in one document
4. **Clear Ownership**: Enhanced fields use `_` prefix
5. **Atomic Updates**: MongoDB positional operators ($) for array updates
6. **API Flexibility**: Fresh API data doesn't conflict with enhanced fields

---

## üéØ Key Design Decisions

### Why Replace Entire Fixture Doc in Monitor?

- API data is authoritative source
- Status and scores change frequently
- Simpler than complex diffing logic
- Enhanced fields get re-added by debounce (they're derived data)

### Why Debounce Per Fixture?

- Each fixture is independent
- Can process in parallel
- Clear job boundaries
- Easy to retry single fixture

### Why Hash-Based Stability?

- API can change event details after posting
- VAR reviews modify goal details
- Need to detect data changes, not just existence
- Hash covers all critical fields

### Why Underscore Prefix?

- Clear separation: API fields vs our fields
- No naming conflicts
- Easy to filter in queries
- Convention: private/internal fields

---

## üìä Performance Considerations

### API Calls

- **Ingest**: 1 call/day (GET /fixtures?date=today)
- **Monitor**: 1 call/minute (GET /fixtures?ids=5000,5001,5002...)
- **Debounce**: 0 calls (uses data from monitor)
- **Twitter**: N calls per event (search + fetch)

**Daily Estimate**: ~1440 calls (1 per minute) + 1 ingest = well under 7500 limit

### MongoDB Operations

- **Monitor**: N replaces (N = active fixtures)
- **Debounce**: M array updates (M = events needing debounce)
- **Twitter**: 1 array update per event

All operations use indexes on `_id` and `events._event_id`.

### Scaling Considerations

- Debounce jobs can run in parallel (per fixture)
- Twitter jobs can run in parallel (per event)
- Monitor is sequential (but fast - just API call + replaces)

---

## üêõ Debugging Tips

### Check Event Status

```javascript
// Find events stuck in debounce
db.fixtures_active.aggregate([
  {$unwind: "$events"},
  {$match: {
    "events._event_id": {$exists: true},
    "events._debounce_complete": false
  }},
  {$project: {
    event_id: "$events._event_id",
    stable_count: "$events._stable_count",
    first_seen: "$events._first_seen",
    snapshots: {$size: "$events._snapshots"}
  }}
])
```

### Trace Event History

```javascript
// Get snapshot history for event
db.fixtures_active.findOne(
  {_id: 5000, "events._event_id": "5000_234_Goal_1"},
  {"events.$": 1}
).events[0]._snapshots
```

### Monitor Job Output

Check Dagster logs for:
- `fixtures_updated: N` - How many fixtures got fresh data
- `fixture_ids_needing_debounce: [...]` - Which fixtures need processing
- `completed_count: N` - How many finished

---

## üìù Future Enhancements

- [ ] Actual Twitter integration (currently placeholder)
- [ ] Video download & deduplication
- [ ] S3 upload with event metadata
- [ ] Frontend UI to query fixtures_active
- [ ] Webhook notifications for completed events
- [ ] Multi-league support

---

## üìú References

- **API-Football Pro**: https://www.api-football.com/documentation-v3
- **MongoDB Positional Operators**: https://docs.mongodb.com/manual/reference/operator/update/positional/
- **Dagster Jobs**: https://docs.dagster.io/concepts/ops-jobs-graphs/jobs
