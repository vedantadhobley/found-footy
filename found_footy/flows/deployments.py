import argparse
import sys
import subprocess
from pathlib import Path
from prefect import get_client

async def ensure_work_pools():
    """Ensure work pools exist before creating deployments using CLI"""
    pools = ["fixtures-pool", "twitter-pool"]  # ‚úÖ CHANGED: twitter-pool instead of youtube-pool
    
    for pool_name in pools:
        try:
            # Check if pool exists using CLI
            result = subprocess.run(
                ["prefect", "work-pool", "inspect", pool_name], 
                capture_output=True, 
                text=True
            )
            
            if result.returncode == 0:
                print(f"‚úÖ {pool_name} already exists")
            else:
                print(f"üîß Creating {pool_name}...")
                # Create pool using CLI
                create_result = subprocess.run(
                    ["prefect", "work-pool", "create", pool_name, "--type", "process"],
                    capture_output=True,
                    text=True
                )
                
                if create_result.returncode == 0:
                    print(f"‚úÖ Created {pool_name}")
                else:
                    print(f"‚ùå Failed to create {pool_name}: {create_result.stderr}")
                    raise Exception(f"Failed to create work pool {pool_name}")
                    
        except Exception as e:
            print(f"‚ùå Error managing work pool {pool_name}: {e}")
            raise

async def clean_all_deployments_api():
    """Clean up ALL existing deployments using Prefect client API"""
    print("üßπ CLEANING ALL EXISTING DEPLOYMENTS (using API)...")
    
    try:
        async with get_client() as client:
            # Get all deployments
            deployments = await client.read_deployments()
            
            if not deployments:
                print("‚ÑπÔ∏è No deployments found to delete")
                return
            
            print(f"üéØ Found {len(deployments)} deployments to delete:")
            for deployment in deployments:
                print(f"  - {deployment.name}")
            
            # Delete each deployment
            deleted_count = 0
            for deployment in deployments:
                try:
                    await client.delete_deployment(deployment.id)
                    print(f"‚úÖ Deleted: {deployment.name}")
                    deleted_count += 1
                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to delete {deployment.name}: {e}")
            
            print(f"‚úÖ API cleanup completed - deleted {deleted_count} deployments")
            
    except Exception as e:
        print(f"‚ö†Ô∏è Error in API cleanup: {e}")
        print("‚úÖ Continuing with deployment creation...")

async def clean_all_automations():
    """Clean up ALL existing automations"""
    print("ü§ñ CLEANING ALL EXISTING AUTOMATIONS...")
    
    try:
        async with get_client() as client:
            # Get all automations
            automations = await client.read_automations()
            
            if not automations:
                print("‚ÑπÔ∏è No automations found to delete")
                return
            
            print(f"üéØ Found {len(automations)} automations to delete:")
            for automation in automations:
                print(f"  - {automation.name}")
            
            # Delete each automation
            deleted_count = 0
            for automation in automations:
                try:
                    await client.delete_automation(automation.id)
                    print(f"‚úÖ Deleted automation: {automation.name}")
                    deleted_count += 1
                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to delete automation {automation.name}: {e}")
            
            print(f"‚úÖ Automation cleanup completed - deleted {deleted_count} automations")
            
    except Exception as e:
        print(f"‚ö†Ô∏è Error in automation cleanup: {e}")

async def create_twitter_automation():
    """Create the Twitter automation using the Prefect API"""
    print("ü§ñ Creating Twitter automation using Prefect API...")
    
    try:
        async with get_client() as client:
            # Get the twitter-flow deployment
            deployments = await client.read_deployments()
            twitter_deployment = None
            
            for deployment in deployments:
                if deployment.name == "twitter-flow":
                    twitter_deployment = deployment
                    break
            
            if not twitter_deployment:
                print("‚ùå twitter-flow deployment not found! Cannot create automation.")
                return False
            
            # ‚úÖ UPDATED: Twitter automation instead of YouTube
            automation_data = {
                "name": "trigger-twitter-on-fixture-completion",
                "description": "Automatically trigger Twitter flow when a fixture completes",
                "enabled": True,
                "trigger": {
                    "type": "event",
                    "expect": ["fixture.completed"],
                    "match": {
                        "prefect.resource.id": "fixture.*"
                    },
                    "posture": "Reactive",
                    "threshold": 1,
                    "within": 0
                },
                "actions": [
                    {
                        "type": "run-deployment",
                        "deployment_id": str(twitter_deployment.id),
                        "parameters": {
                            "team1": "{{ event.payload.home_team }}",
                            "team2": "{{ event.payload.away_team }}",
                            "match_date": "{{ event.occurred.strftime('%Y-%m-%d') }}"
                        }
                    }
                ]
            }
            
            # Use the client's HTTP session directly
            response = await client._client.post("/automations/", json=automation_data)
            
            if response.status_code == 201:
                created_automation = response.json()
                print(f"‚úÖ Created automation: {created_automation['name']} (ID: {created_automation['id']})")
                print("üê¶ Twitter worker will now respond to fixture completion events!")
                return True
            else:
                print(f"‚ùå Failed to create automation via HTTP: {response.status_code} - {response.text}")
                return False
            
    except Exception as e:
        print(f"‚ùå Failed to create automation: {e}")
        import traceback
        traceback.print_exc()
        return False

def deploy_from_yaml():
    """Deploy using prefect.yaml project config - THE RIGHT WAY"""
    print("üöÄ Creating SIMPLIFIED deployments (only 3) using prefect.yaml...")
    
    # ‚úÖ FIXED: Reset MongoDB with team metadata instead of league metadata
    print("üóëÔ∏è Resetting MongoDB on application startup...")
    from found_footy.api.mongo_api import populate_team_metadata
    populate_team_metadata(reset_first=True)
    print("‚úÖ MongoDB reset and team initialization complete")
    
    # Ensure pools exist first
    import asyncio
    asyncio.run(ensure_work_pools())
    
    # Clean existing deployments and automations (Prefect only)
    asyncio.run(clean_all_deployments_api())
    asyncio.run(clean_all_automations())
    
    # NOTE: MongoDB reset happens automatically when fixtures_flow runs
    # This keeps infrastructure concerns (Prefect) separate from data concerns (MongoDB)
    print("‚ÑπÔ∏è MongoDB will be reset automatically when fixtures_flow starts")
    
    # Wait for cleanup
    print("‚è≥ Waiting 3 seconds for cleanup to complete...")
    import time
    time.sleep(3)
    
    # ‚úÖ Use the correct command: prefect deploy --all
    print("üèóÔ∏è Deploying 3 deployments from prefect.yaml...")
    
    result = subprocess.run([
        "prefect", "deploy", "--all"
    ], capture_output=True, text=True, cwd="/app")
    
    if result.returncode == 0:
        print("‚úÖ All deployments created successfully from prefect.yaml!")
        print(f"üìã Output: {result.stdout}")
        
        # ‚úÖ UPDATED: Create Twitter automation instead of YouTube
        print("ü§ñ Creating Twitter automation...")
        automation_success = asyncio.run(create_twitter_automation())
        
        if automation_success:
            print("‚úÖ Setup complete with automation!")
        else:
            print("‚ö†Ô∏è Deployments created but automation failed")
        
        # ‚úÖ UPDATED: Show Twitter flow info
        print("\n" + "="*60)
        print("üéâ SETUP COMPLETE - Team-Based Fixture Monitoring!")
        print("="*60)
        print("üìã Deployments created:")
        print("  1. fixtures-flow-daily    (scheduled, DISABLED by default)")
        print("  2. fixtures-flow-manual   (manual trigger)")
        print("  3. twitter-flow          (auto-triggered by events)")
        print()
        print("üöÄ Next steps:")
        print("  1. Go to Prefect UI: http://localhost:4200")
        print("  2. For daily monitoring:")
        print("     ‚Üí Deployments ‚Üí fixtures-flow-daily ‚Üí Edit parameters")
        print("     ‚Üí Set team_ids (e.g., '[541,50,42]' for top teams)")
        print("     ‚Üí Enable schedule when ready")
        print("  3. For immediate runs:")
        print("     ‚Üí Deployments ‚Üí fixtures-flow-manual ‚Üí Run")
        print("     ‚Üí Set date_str and team_ids ‚Üí Quick Run")
        print()
        print("‚öΩ Team ID examples (Top 25 UEFA 2026):")
        print("  ‚Ä¢ '[541]' - Real Madrid only")  
        print("  ‚Ä¢ '[50,42]' - Manchester City + Liverpool")
        print("  ‚Ä¢ '[541,529,50,42]' - Real Madrid, Barcelona, Man City, Liverpool")
        print("  ‚Ä¢ null/empty - All top 25 UEFA teams")
        print("="*60)
        
        return True
    else:
        print(f"‚ùå Failed to deploy from prefect.yaml:")
        print(f"   stdout: {result.stdout}")
        print(f"   stderr: {result.stderr}")
        return False

def run_immediate():
    """Run the fixtures flow immediately for today's date"""
    print("üèÉ Running fixtures flow immediately for today...")
    print("üîç About to call fixtures_flow()...")
    try:
        from found_footy.flows.fixtures_flow import fixtures_flow
        result = fixtures_flow()
        print(f"‚úÖ Immediate run completed successfully: {result}")
    except Exception as e:
        print(f"‚ùå Immediate run failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    print(f"üêõ DEBUG: Command line args: {sys.argv}")
    
    parser = argparse.ArgumentParser()
    parser.add_argument("--apply", action="store_true", help="Apply all deployments")
    parser.add_argument("--run-now", action="store_true", help="Also run immediately")
    parser.add_argument("--clean-only", action="store_true", help="Only clean deployments, don't recreate")
    args = parser.parse_args()
    
    print(f"üêõ DEBUG: Parsed args - apply: {args.apply}, run_now: {args.run_now}, clean_only: {args.clean_only}")
    
    if args.clean_only:
        print("üßπ CLEAN-ONLY MODE: Deleting all deployments...")
        import asyncio
        asyncio.run(clean_all_deployments_api())
        asyncio.run(clean_all_automations())
        print("‚úÖ Clean-only completed!")
    elif args.apply:
        print("üìã Creating SIMPLIFIED deployments from YAML configs...")
        # ‚úÖ USE YAML DEPLOYMENT INSTEAD OF SERVE
        success = deploy_from_yaml()
        
        if success and args.run_now:
            print("üö® DEBUG: run_now flag is True, calling run_immediate()")
            run_immediate()
        elif not success:
            print("‚ùå Deployment failed, skipping immediate run")
        else:
            print("‚ö†Ô∏è DEBUG: run_now flag is False, skipping immediate run")
        
        print("‚úÖ Setup complete!")
        print("üåê Access Prefect UI at http://localhost:4200")
        print("üìù Configure team_ids in deployment parameters")
    else:
        print("‚ùå DEBUG: apply flag is False")
        print("Use --apply to create deployments")
        print("Use --apply --run-now to also run immediately")
        print("Use --clean-only to just delete all deployments")